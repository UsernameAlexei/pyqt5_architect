# pyqt5_architect

## 1. Мин.структура
### Изоляция:
1. `.ui` (Designer) — только разметка и стили: кнопки, поля, лейауты
2. `main.py` (логика/связи) — подключение .ui, соединение сигналов и слотов, бизнес-логика
3. `widgets/…` (кастом-виджеты) — отдельные классы для особого поведения

```bash
myapp/
  app/
    main_without_convert.py                    # логика и запуск
    ui/
      MainWindow.ui            # файл из Qt Designer
      # (опционально) ui_mainwindow.py  # если генерируете pyuic5
    widgets/
      __init__.py
      custom_button.py         # пример кастом-виджета
  venv/ (необязательно)
  README.md
```
## Создаем `.ui`
Создаем в qtdesigner

## Использование `.ui`
В UI не пишем логику: только имена объектов, тексты и лейауты.
### Вариант - загружать напрямую
- Плюсы - не нужно генерировать .py при каждом изменении UI, меньше артефактов.
- Минусы - промотируемые виджеты нужно «показать» Python до загрузки.

## Создаем кастом-виджет
После создания, можно сделать promotion:
- В макете оставьте обычный виджет, например QPushButton. 
- Правый клик → Promote to… 
- Base class name: QPushButton. 
- Promoted class name: ColorButton, кастомный виджет из проекта
- Header file: widgets.custom_button, кастомный виджет из проекта
- Далее Add, затем Promote. Сохраняем .ui.

Теперь при загрузке .ui будет создан ColorButton вместо обычной кнопки, а в коде можно указывать self.btnColor.colorChanged.connect(...).

## Сигналы и слоты - как работают
- Готовые сигналы, например: ``QPushButton.clicked``, ``QLineEdit.textChanged``, ``QCheckBox.toggled``
- Подключение, пример из текущей реализации: 
    ```
    self.btnHello.clicked.connect(self.on_hello_clicked)
    self.editName.textChanged.connect(self.on_name_changed)
    ```
- Кастомные сигналы, через pyqtSignal(...) в классе испускаются методом .emit(...) (пример ColorButton)
- Слоты, обычные методы класса

## Итоги
### Хорошая практика:
- Говорящие objectName (например, editName).
- Изолирование слоёв: Designer (.ui) для внешнего вида; код на Python — для логики и сигналов.
- Хранение кастом-виджетов в widgets/ и подключение их в .ui через promotion.
- Длинные/тяжёлые операции выносим из UI-потока (QThread/moveToThread).
- Для сборки/релиза можно компилировать .ui → .py, а при разработке — uic.loadUi().

### Плохая практика:
- Написание бизнес-логики в генерируемом файле ui_mainwindow.py.
- Смешивание всё в одном монолитном main.py (правильно - выносить в повторно используемые виджеты).
- Забывать импортировать кастом-виджеты до uic.loadUi() (или компилировать .ui с корректным модулем).